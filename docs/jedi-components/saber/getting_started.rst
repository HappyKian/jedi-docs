Getting started
---------------

**BUMP** can be run in two different ways:

* as a library from another code (e.g. within :ref:`top-oops`)
* as a standalone executable

Using BUMP within OOPS
**********************

To use **BUMP** as an ensemble, a static or a hybrid covariance matrix model, you need to proceed in two successive steps:

1. Run the :code:`EstimateParams.h` to generate the various operators data.

2. Run :code:`Variational.h` or :code:`Dirac.h`, reading the pre-computed data

**IMPORTANT:** both steps should be run with the same number of MPI tasks and the same grid distribution among these tasks.

Operators generation
^^^^^^^^^^^^^^^^^^^^

This section provides some examples of the :code:`bump` section of the yaml inputs of :code:`EstimateParams.h`:

* For an ensemble covariance matrix, the localization operator generated by the NICAS driver **BUMP** can be set either with forced horizontal and vertical length-scales:

  .. code-block:: yaml

    bump:
      datadir: path_to_bump_directory  # BUMP data directory
      forced_radii: 1                  # Force NICAS length-scales
      method: loc                      # Compute localization parameters
      mpicom: 2                        # Number of internal MPI communication steps in NICAS, 2 is good
      new_nicas: 1                     # Run NICAS driver
      ntry: 10                         # Number of tries for and NICAS subsamplings
      prefix: my_bump_files            # BUMP files prefix
      resol: 8.0                       # NICAS subgrid resolution
      rh: 1000.0e3                     # Horizontal radius (in m)
      rv: 2000.0                       # Horizontal radius (in the unit provided in the OOPS-SABER interface)
      strategy: common                 # NICAS multivariate strategy (here: same localization for all variables)

  or with length-scales diagnosed from the ensemble:

  .. code-block:: yaml

    bump:
      datadir: path_to_bump_directory  # BUMP data directory
      dc: 500.0e3                      # Distance class size (in m) in HDIAG
      method: loc                      # Compute localization parameters
      mpicom: 2                        # Number of internal MPI communication steps in NICAS, 2 is good
      nc1: 500                         # Number of subsampling points in HDIAG
      nc3: 20                          # Number of distance classes in HDIAG
      ne: 10                           # Ensemble size
      new_hdiag: 1                     # Run HDIAG driver
      new_nicas: 1                     # Run NICAS driver
      nl0r: 2                          # Number of reduced levels in HDIAG
      ntry: 10                         # Number of tries for HDIAG and NICAS subsamplings
      prefix: my_bump_files            # BUMP files prefix
      resol: 8.0                       # NICAS subgrid resolution
      strategy: common                 # HDIAG and NICAS multivariate strategy (here: same localization for all variables)

* Similarly for a static covariance matrix, the correlation operator generated by the NICAS driver **BUMP** can be set either with forced horizontal and vertical length-scales:

  .. code-block:: yaml

    bump:
      datadir: path_to_bump_directory  # BUMP data directory
      forced_radii: 1                  # Force NICAS length-scales
      method: cor                      # Compute correlation parameters
      mpicom: 2                        # Number of internal MPI communication steps in NICAS, 2 is good
      new_nicas: 1                     # Run NICAS driver
      ntry: 10                         # Number of tries for and NICAS subsamplings
      prefix: my_bump_files            # BUMP files prefix
      resol: 8.0                       # NICAS subgrid resolution
      rh: 1000.0e3                     # Horizontal radius (in m)
      rv: 2000.0                       # Horizontal radius (in the unit provided in the OOPS-SABER interface)
      strategy: specific_univariate    # NICAS multivariate strategy (here: specific auto-correlation for each variable)

  or with length-scales diagnosed from the ensemble:

  .. code-block:: yaml

    bump:
      datadir: path_to_bump_directory  # BUMP data directory
      dc: 500.0e3                      # Distance class size (in m) in HDIAG
      method: cor                      # Compute correlation parameters
      mpicom: 2                        # Number of internal MPI communication steps in NICAS, 2 is good
      nc1: 500                         # Number of subsampling points in HDIAG
      nc3: 20                          # Number of distance classes in HDIAG
      ne: 10                           # Ensemble size
      new_hdiag: 1                     # Run HDIAG driver
      new_nicas: 1                     # Run NICAS driver
      nl0r: 2                          # Number of reduced levels in HDIAG
      ntry: 10                         # Number of tries for HDIAG and NICAS subsamplings
      prefix: my_bump_files            # BUMP files prefix
      resol: 8.0                       # NICAS subgrid resolution
      strategy: specific_univariate    # HDIAG and NICAS multivariate strategy (here: specific auto-correlation for each variable)

  Other operators that can be useful for the static covariance matrix - vertical balance and variance - can be generated simultaneously using the ensemble. The corresponding yaml keys in the :code:`bump` section are:

  * For the vertical balance:

    .. code-block:: yaml

      bump: # (continued)
        new_vbal: 1                      # Run VBAL driver
        vbal_block: [0,1,1,0,1,0]        # Activate the multivariate blocks
                                         # Here with 3 variables, the blocks K2, K3 and K5 are activated:
                                         # K = [I  0  0  0]
                                         #     [K1 I  0  0]
                                         #     [K2 K3 I  0]
                                         #     [K4 K5 K6 I]
        vbal_rad: 3000.0e3               # Vertical balance averaging radius

  * For the variance:

    .. code-block:: yaml

      bump: # (continued)
        new_var: 1                       # Run VAR driver
        ne: 10                           # Ensemble size
        var_filter: 1                    # Activate variance filtering
        var_niter: 3                     # Number of iterations for the variance filtering
        var_rhflt: 1000.0e3              # Initial radius for the variance filtering

Operators application
^^^^^^^^^^^^^^^^^^^^^

This section provides some examples of the :code:`bump` section of the yaml inputs where the pre-computed **BUMP** operators are read:

* For the VBAL operator, the :code:`bump` section is inserted in the :code:`StatsVariableChange` variable change:

  .. code-block:: yaml

    background error:
      variable changes:
      - variable change: StatsVariableChange
        bump:
          datadir: path_to_bump_directory  # BUMP data directory
          load_vbal: 1                     # Load VBAL data
          vbal_block: [0,1,1,0,1,0]        # Activate the multivariate blocks
          prefix: my_bump_files            # BUMP files prefix

* For the VAR operator, the :code:`bump` section is inserted in the :code:`StdDev` variable change:

  .. code-block:: yaml

    background error :
      variable changes:
      - variable change: StdDev
        bump:
          datadir: path_to_bump_directory  # BUMP data directory
          load_var: 1                      # Load VAR data
          prefix: my_bump_files            # BUMP files prefix

* For the localization operator of the ensemble covariance matrix, the :code:`bump` section is inserted in the :code:`background error` section, with the :code:`localization method` key set to :code:`BUMP`:

  .. code-block:: yaml

    background error:
      covariance model: ensemble           # Covariance model
      localization:
        bump:
          datadir: path_to_bump_directory  # BUMP data directory
          mpicom: 2                        # Number of internal MPI communication steps in NICAS, 2 is good
          load_nicas: 1                    # Load NICAS data
          prefix: my_bump_files            # BUMP files prefix
          strategy: common                 # NICAS multivariate strategy
        localization method: BUMP          # Localization method
        localization variables: [array]    # Localization_variables
      members: [array]                     # Ensemble members

* For the correlation operator of the static covariance matrix, the :code:`bump` section is inserted in the :code:`background error` section, with the :code:`covariance model` key set to :code:`BUMP`:

  .. code-block:: yaml

    background error:
      bump:
        datadir: path_to_bump_directory  # BUMP data directory
        mpicom: 2                        # Number of internal MPI communication steps in NICAS, 2 is good
        load_nicas: 1                    # Load NICAS data
        prefix: my_bump_files            # BUMP files prefix
        strategy: specific_univariate    # NICAS multivariate strategy
      covariance model: BUMP             # Covariance model

* The hybrid covariance matrix is just a linear combination of both ensemble and static covariance matrices. Thus, you can use **BUMP** for either the ensemble part, the static part, or both:

  .. code-block:: yaml

    background error:
      covariance model: hybrid               # Covariance model
      static:
        # Static covariance model (BUMP or other)
      static weight: float                   # Static weights
      ensemble:
        localization:
          # Localization method (BUMP or other)
          localization method: string        # Localization method
          localization variables: [array]    # Localization_variables
        members: [array]                     # Ensemble members
      ensemble weight: float                 # Ensemble weights

  **IMPORTANT:** the :code:`static weight` and :code:`ensemble weight` values are those of :math:`\beta_s` and :math:`\beta_e`, used in the linear combination of the increment components. They are **not** equal to their squared counterparts :math:`\beta_s^2` and :math:`\beta_e^2` used in the linear combination of the covariance matrices (see :ref:`BUMP-goals_and_code_organization`).

Alias system
^^^^^^^^^^^^

If you wish to apply the same NICAS operator to several variables, you can define an alias that is used at both generation and application steps, in order to save computing time and memory.

For instance, the static correlation operator is generated and applied with the :code:`method: specific_univariate` (specific auto-correlation for each variable), and the same length-scales for the 5 variables: :code:`u, v, T, q` that are 3D and :code:`ps` that is 2D.

Instead of running :code:`EstimateParams.h` for this 5 variables, you can run it for one 3D and one 2D variables only (for instance :code:`T` and :code:`ps`), and add the following keys in the yaml file:

.. code-block:: yaml

  bump: # (continued)
    io_keys:
    - T_T
    - ps_ps
    io_values:
    - static_3D
    - static_2D

In the application step, you can use these keys in the yaml file to apply the same 3D operators to all 3D variables:

.. code-block:: yaml

  bump: # (continued)
    io_keys:
    - u_u
    - v_v
    - T_T
    - q_q
    - ps_ps
    io_values:
    - static_3D
    - static_3D
    - static_3D
    - static_3D
    - static_2D


Using BUMP as a standalone executable
*************************************

The executable :code:`bump.x`, used for **BUMP** tests, is available to run all drivers directly, without running OOPS. In this case, two kinds of inputs are required:

* A :code:`grid.nc` file containing the coordinates.
* Ensemble members with the following name: :code:`ens$E_$NNNNNN.nc`, where:

   * :code:`$E` is the ensemble number (1 or 2)
   * :code:`$NNNNNN` is the ensemble member index (six digits)

They should all be placed in the directory :code:`datadir`, specified in the input yaml file.

Specific reading routines should be implemented. Some are already present:

* `ARPEGE <http://www.cnrm-game-meteo.fr/spip.php?article121&lang=en>`_
* `AROME <http://www.cnrm-game-meteo.fr/spip.php?article120&lang=en>`_
* `FV3 <(https://www.gfdl.noaa.gov/fv3>`_
* `GEM <https://en.wikipedia.org/wiki/Global_Environmental_Multiscale_Model>`_
* `GEOS <https://gmao.gsfc.nasa.gov/GEOS>`_
* `GFS <https://www.ncdc.noaa.gov/data-access/model-data/model-datasets/global-forcast-system-gfs>`_
* `IFS <http://www.ecmwf.int/en/research/modelling-and-prediction>`_
* `MPAS <https://mpas-dev.github.io>`_
* `NEMO <http://www.nemo-ocean.eu>`_
* `NORCPM <https://wiki.uib.no/norcpm>`_
* RES (oil reservoir model used by Total)
* `WRF <https://www.mmm.ucar.edu/weather-research-and-forecasting-model>`_

To add a new model :code:`$MODEL` in the **BUMP** executable, you need to write an include file :code:`mains/model/model_$MODEL.inc` containing two routines:

* :code:`model_$MODEL_coord` to get the model coordinates,
* :code:`model_$MODEL_read` to read a model field.

You also need to add:

* corresponding calls in :code:`mains/model/type_model.F90`,
* a case for the namelist check in the routine :code:`nam_check`, contained in :code:`src/bump/type_nam.f90`.

For models with a regular grid, you can start from AROME, ARPEGE, FV3, GEM, GEOS, GFS, IFS, NEMO, NORCPM and WRF routines. For models with an unstructured grid, you can start from MPAS and RES routines.
